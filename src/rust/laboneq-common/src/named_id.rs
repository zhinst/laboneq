// Copyright 2025 Zurich Instruments AG
// SPDX-License-Identifier: Apache-2.0

use regex::Regex;
use string_interner::Symbol;
use string_interner::symbol::SymbolU32;
use string_interner::{DefaultBackend, StringInterner};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NamedId {
    uid: SymbolU32,
}

impl std::fmt::Display for NamedId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NamedId({})", self.uid.to_usize())
    }
}

impl NamedId {
    /// Create a debug NamedId from a given integer.
    ///
    /// This is only for testing and debugging purposes.
    #[cfg(feature = "test_utils")]
    pub fn debug_id(uid: u32) -> Self {
        NamedId {
            uid: SymbolU32::try_from_usize(uid as usize).unwrap(),
        }
    }
}

/// A store for named IDs.
///
/// The store maps strings to unique IDs and allows resolving IDs back to strings.
/// To resolve the IDs in a message, use the `resolve_ids` function.
#[derive(Default)]
pub struct NamedIdStore {
    interner: StringInterner<DefaultBackend>,
}

impl NamedIdStore {
    pub fn new() -> Self {
        NamedIdStore {
            interner: StringInterner::new(),
        }
    }

    /// Return a unique ID for a given name, otherwise None.
    pub fn get(&self, name: impl AsRef<str>) -> Option<NamedId> {
        self.interner.get(name).map(|uid| NamedId { uid })
    }

    /// Return a unique ID for a given name, inserting it if necessary.
    pub fn get_or_insert(&mut self, name: impl AsRef<str>) -> NamedId {
        let uid = self.interner.get_or_intern(name);
        NamedId { uid }
    }

    /// Resolve a unique ID to its original string.
    pub fn resolve(&self, uid: impl Into<NamedId>) -> Option<&str> {
        self.interner.resolve(Into::<NamedId>::into(uid).uid)
    }
}

/// Create a new message with resolved named IDs.
///
/// The function replaces the patterns generated by [NamedId] `Display` implementation.
pub fn resolve_ids(value: &str, id_store: &NamedIdStore) -> String {
    let mut msg = value.to_string();
    let re = Regex::new(r"NamedId\((\d+)\)").unwrap();
    for cap in re.captures_iter(value) {
        let id = &cap[1];
        let id: usize = id.parse().unwrap();
        let named_id = NamedId {
            uid: SymbolU32::try_from_usize(id).expect("Internal error: ID overflow"), // Should not happen unless ID placeholder is set manually
        };
        if let Some(name) = id_store.resolve(named_id) {
            msg = msg.replace(&format!("NamedId({id})"), name);
        }
    }
    msg
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_named_id_store() {
        let mut store = NamedIdStore::new();
        let id1 = store.get_or_insert("test");
        let id2 = store.get_or_insert("test");
        assert_eq!(id1, id2);
        assert_eq!(store.resolve(id1), Some("test"));

        let id3 = store.get_or_insert("test2");
        let id4 = store.get_or_insert("test2");
        assert_ne!(id1, id3);
        assert_eq!(id3, id4);
        assert_eq!(store.resolve(id3), Some("test2"));

        let id5 = store.get("test2").unwrap();
        let id6 = store.get("test2").unwrap();
        assert_ne!(id1, id5);
        assert_eq!(id5, id6);
        assert_eq!(store.resolve(id5), Some("test2"));
    }

    #[test]
    fn test_resolve_ids() {
        let mut store = NamedIdStore::new();
        let id1 = store.get_or_insert("test1");
        let id2 = store.get_or_insert("test2");
        let msg = format!("Replace the IDs: {id1}, {id2}, {id1}");
        let msg_resolved = resolve_ids(&msg, &store);
        assert!(
            msg_resolved.contains("Replace the IDs: test1, test2, test1"),
            "{msg_resolved}",
        );
    }
}
