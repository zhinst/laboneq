// Copyright 2026 Zurich Instruments AG
// SPDX-License-Identifier: Apache-2.0

//! Schedule generation for Pulse Sheet Viewer (PSV).
//!
//! This module generates a Schedule containing:
//! - event_list: Time-ordered list of scheduler events
//! - section_info: Section metadata with preorder map
//! - section_signals_with_children: Signal hierarchy per section
//!
//! The event list is generated by traversing an IR tree and creating time-ordered scheduler events.
//! The event list is primarily consumed by the Pulse Sheet Viewer (PSV) for visualization.
//!
//! Note: sampling_rates is generated separately in Python (depends on SamplingRateTracker).

use std::collections::HashMap;

use laboneq_common::named_id::NamedIdStore;
use laboneq_dsl::types::{MarkerSelector, SectionUid, SignalUid};
use laboneq_units::tinysample::{TINYSAMPLE_DURATION, TinySamples};
use serde::Serialize;

use crate::IrKind;
use crate::node::IrNode;

const UNKNOWN_LABEL: &str = "unknown";

// =============================================================================
// EVENT TYPE CONSTANTS
// =============================================================================

pub mod event_type {
    pub const SECTION_START: &str = "SECTION_START";
    pub const SECTION_END: &str = "SECTION_END";
    pub const DIGITAL_SIGNAL_STATE_CHANGE: &str = "DIGITAL_SIGNAL_STATE_CHANGE";
    pub const PLAY_START: &str = "PLAY_START";
    pub const PLAY_END: &str = "PLAY_END";
    pub const ACQUIRE_START: &str = "ACQUIRE_START";
    pub const ACQUIRE_END: &str = "ACQUIRE_END";
    pub const LOOP_STEP_START: &str = "LOOP_STEP_START";
    pub const LOOP_STEP_END: &str = "LOOP_STEP_END";
    pub const LOOP_ITERATION_END: &str = "LOOP_ITERATION_END";
    pub const LOOP_END: &str = "LOOP_END";
    pub const PARAMETER_SET: &str = "PARAMETER_SET";
    pub const DELAY_START: &str = "DELAY_START";
    pub const DELAY_END: &str = "DELAY_END";
    pub const SET_OSCILLATOR_FREQUENCY_START: &str = "SET_OSCILLATOR_FREQUENCY_START";
    pub const SUBSECTION_START: &str = "SUBSECTION_START";
    pub const SUBSECTION_END: &str = "SUBSECTION_END";
}

// =============================================================================
// PUBLIC TYPES
// =============================================================================

/// Schedule output containing event list and metadata for PSV.
#[derive(Debug, Clone, Serialize)]
pub struct Schedule {
    /// Time-ordered list of scheduler events
    pub event_list: EventList,

    /// Section metadata with display names and preorder
    pub section_info: HashMap<String, SectionInfo>,

    /// Signal hierarchy per section (parent sections include child signals)
    pub section_signals_with_children: HashMap<String, Vec<String>>,
}

/// Metadata for a section in the schedule.
#[derive(Debug, Clone, Serialize)]
pub struct SectionInfo {
    pub section_display_name: String,
    pub preorder: usize,
}

// =============================================================================
// INTERNAL TYPES
// =============================================================================

/// A single scheduler event in the event list.
///
/// Events are serialized to JSON with None values omitted.
#[derive(Debug, Clone, Serialize)]
pub struct SchedulerEvent {
    pub event_type: &'static str,
    pub time: f64, // In seconds (converted from TinySamples)

    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<usize>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub section_name: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub chain_element_id: Option<usize>,

    // Additional fields stored as dynamic map
    #[serde(flatten)]
    #[serde(skip_serializing_if = "HashMap::is_empty")]
    pub extra: HashMap<String, serde_json::Value>,
}

impl SchedulerEvent {
    fn new(event_type: &'static str, time_ts: TinySamples) -> Self {
        let time = time_ts.value() as f64 * TINYSAMPLE_DURATION;
        Self {
            event_type,
            time,
            id: None,
            signal: None,
            section_name: None,
            chain_element_id: None,
            extra: HashMap::new(),
        }
    }

    fn with_id(mut self, id: usize) -> Self {
        self.id = Some(id);
        self
    }

    fn with_signal(mut self, signal: &str) -> Self {
        self.signal = Some(signal.to_string());
        self
    }

    fn with_section_name(mut self, section_name: &str) -> Self {
        self.section_name = Some(section_name.to_string());
        self
    }

    fn with_chain_element_id(mut self, chain_id: usize) -> Self {
        self.chain_element_id = Some(chain_id);
        self
    }

    fn with_extra(mut self, key: impl Into<String>, value: impl Into<serde_json::Value>) -> Self {
        self.extra.insert(key.into(), value.into());
        self
    }

    fn with_extras(mut self, extras: HashMap<String, serde_json::Value>) -> Self {
        self.extra.extend(extras);
        self
    }
}

/// A list of scheduler events, time-ordered.
pub type EventList = Vec<SchedulerEvent>;

/// Parameters for creating bracketed events.
struct BracketedEventParams<'a> {
    start_type: &'static str,
    end_type: &'static str,
    signal_name: &'a str,
    start_time: TinySamples,
    end_time: TinySamples,
}

impl<'a> BracketedEventParams<'a> {
    fn new(
        start_type: &'static str,
        end_type: &'static str,
        signal_name: &'a str,
        start_time: TinySamples,
        end_time: TinySamples,
    ) -> Self {
        Self {
            start_type,
            end_type,
            signal_name,
            start_time,
            end_time,
        }
    }
}

/// Marker JSON structure for serialization.
#[derive(Debug, Clone, Serialize)]
struct MarkerJson {
    marker_selector: String,
    enable: bool,
    start: Option<f64>,
    length: Option<f64>,
    pulse_id: Option<String>,
}

/// Time interval for tracking section overlaps during preorder calculation.
#[derive(Debug, Clone, Copy)]
struct PreorderInterval {
    start: TinySamples,
    end: TinySamples,
}

impl PreorderInterval {
    fn overlaps(&self, other: &PreorderInterval) -> bool {
        self.start < other.end && self.end > other.start
    }

    fn merge(&self, other: &PreorderInterval) -> PreorderInterval {
        PreorderInterval {
            start: self.start.min(other.start),
            end: self.end.max(other.end),
        }
    }
}

/// Event list generator using visitor pattern.
struct EventListGenerator<'a> {
    id_counter: usize,
    expand_loops: bool,
    section_stack: Vec<String>,
    iteration_counter: HashMap<String, usize>,
    id_store: &'a NamedIdStore,
}

// =============================================================================
// EVENTLISTGENERATOR IMPLEMENTATION
// =============================================================================

impl<'a> EventListGenerator<'a> {
    fn new(expand_loops: bool, id_store: &'a NamedIdStore) -> Self {
        Self {
            id_counter: 0,
            expand_loops,
            section_stack: Vec::new(),
            iteration_counter: HashMap::new(),
            id_store,
        }
    }

    fn try_reserve_events(max_events: &mut usize, count: usize) -> bool {
        if *max_events < count {
            return false;
        }
        *max_events = max_events.saturating_sub(count);
        true
    }

    fn generate(
        root: &IrNode,
        expand_loops: bool,
        max_events: usize,
        id_store: &'a NamedIdStore,
    ) -> EventList {
        let mut generator = Self::new(expand_loops, id_store);
        let mut remaining = max_events;
        generator.visit_node(root, TinySamples::default(), &mut remaining)
    }

    fn resolve_signal(&self, signal: &SignalUid) -> String {
        self.id_store
            .resolve(*signal)
            .unwrap_or(UNKNOWN_LABEL)
            .to_string()
    }

    fn resolve_section(&self, section: &SectionUid) -> String {
        self.id_store
            .resolve(*section)
            .unwrap_or(UNKNOWN_LABEL)
            .to_string()
    }

    fn get_parameter_name<T>(
        &self,
        param: &laboneq_dsl::types::ValueOrParameter<T>,
    ) -> Option<String> {
        match param {
            laboneq_dsl::types::ValueOrParameter::Parameter(uid)
            | laboneq_dsl::types::ValueOrParameter::ResolvedParameter { uid, .. } => {
                self.id_store.resolve(*uid).map(|s| s.to_string())
            }
            laboneq_dsl::types::ValueOrParameter::Value(_) => None,
        }
    }

    fn next_id(&mut self) -> usize {
        let id = self.id_counter;
        self.id_counter += 1;
        id
    }
    fn current_section_name(&self) -> Option<&str> {
        self.section_stack.last().map(|s| s.as_str())
    }

    fn visit_node(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        if *max_events == 0 {
            return Vec::new();
        }

        let section_info = node.kind.section_info();
        let pushed_section = if let Some(info) = &section_info {
            let section_name = self.resolve_section(info.uid);
            self.section_stack.push(section_name.clone());
            Some(section_name)
        } else {
            None
        };

        let events = match &node.kind {
            IrKind::Root => self.visit_root(node, start, max_events),
            IrKind::Section(section) => self.visit_section(node, section, start, max_events),
            IrKind::Loop(loop_ir) => self.visit_loop(node, loop_ir, start, max_events),
            IrKind::LoopIteration => self.visit_loop_iteration(node, start, max_events),
            IrKind::LoopIterationPreamble => {
                self.visit_loop_iteration_preamble(node, start, max_events)
            }
            IrKind::PlayPulse(play_pulse) => {
                self.visit_play_pulse(node, play_pulse, start, max_events)
            }
            IrKind::Acquire(acquire) => self.visit_acquire(node, acquire, start, max_events),
            IrKind::Match(match_ir) => self.visit_match(node, match_ir, start, max_events),
            IrKind::Case(case_ir) => self.visit_case(node, case_ir, start, max_events),
            IrKind::SetOscillatorFrequency(set_freq) => {
                self.visit_set_oscillator_frequency(set_freq, start, max_events)
            }
            IrKind::InitialOscillatorFrequency(_) => Vec::new(),
            IrKind::InitialLocalOscillatorFrequency(_) => Vec::new(),
            IrKind::ChangeOscillatorPhase(change) => {
                self.visit_change_oscillator_phase(node, change, start, max_events)
            }
            IrKind::ResetOscillatorPhase { .. } => self.generic_visit(node, start, max_events),
            IrKind::Delay { signal } => self.visit_delay(node, signal, start, max_events),
            _ => self.generic_visit(node, start, max_events),
        };

        if pushed_section.is_some() {
            self.section_stack.pop();
        }

        events
    }

    fn generic_visit(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let mut events = Vec::new();

        for child in &node.children {
            if *max_events == 0 {
                break;
            }

            let child_events = self.visit_node(&child.node, start + child.offset, max_events);
            events.extend(child_events);
        }

        events
    }

    fn generate_children_events(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
        wrap_subsections: bool,
    ) -> Vec<EventList> {
        let mut event_lists = Vec::new();

        if wrap_subsections {
            let subsection_count = node
                .children
                .iter()
                .filter(|c| c.node.kind.section_info().is_some())
                .count();
            *max_events = max_events.saturating_sub(subsection_count * 2);
        }

        for child in &node.children {
            if *max_events == 0 {
                break;
            }

            let child_events = self.visit_node(&child.node, start + child.offset, max_events);
            event_lists.push(child_events);
        }

        while event_lists.len() < node.children.len() {
            event_lists.push(Vec::new());
        }

        if wrap_subsections {
            for (i, child) in node.children.iter().enumerate() {
                if let Some(info) = child.node.kind.section_info()
                    && *max_events >= 2
                {
                    let start_id = self.next_id();
                    let end_id = self.next_id();
                    let parent_section = self.current_section_name().unwrap().to_string();
                    let subsection_name = self.resolve_section(info.uid);

                    let subsection_start =
                        SchedulerEvent::new(event_type::SUBSECTION_START, start + child.offset)
                            .with_id(start_id)
                            .with_section_name(&parent_section)
                            .with_chain_element_id(start_id)
                            .with_extra(
                                "subsection_name".to_string(),
                                serde_json::Value::String(subsection_name.clone()),
                            );

                    let subsection_end = SchedulerEvent::new(
                        event_type::SUBSECTION_END,
                        start + child.offset + child.node.length,
                    )
                    .with_id(end_id)
                    .with_section_name(&parent_section)
                    .with_chain_element_id(start_id)
                    .with_extra(
                        "subsection_name".to_string(),
                        serde_json::Value::String(subsection_name),
                    );

                    let mut wrapped = vec![subsection_start];
                    wrapped.append(&mut event_lists[i]);
                    wrapped.push(subsection_end);
                    event_lists[i] = wrapped;
                }
            }
        }

        event_lists
    }

    fn visit_root(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        self.generic_visit(node, start, max_events)
    }

    fn visit_section(
        &mut self,
        node: &IrNode,
        section: &crate::ir::Section,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        if !Self::try_reserve_events(max_events, 2) {
            return Vec::new();
        }

        let children_events = self.generate_children_events(node, start, max_events, true);

        let mut trigger_set_events = Vec::new();
        let mut trigger_clear_events = Vec::new();

        // Skip trigger events for zero-length sections: the PSV frontend removes
        // zero-length section start/end events but not their trigger events, which
        // causes a crash when the JS tries to look up the removed section.
        // A zero-length trigger SET+CLEAR at the same instant is a no-op anyway.
        let has_length = node.length > TinySamples::default();
        for trigger in section.triggers.iter().filter(|_| has_length) {
            let signal_name = self.resolve_signal(&trigger.signal);
            let active_bits = extract_active_bits(trigger.state);

            for bit_position in active_bits {
                if !Self::try_reserve_events(max_events, 2) {
                    break;
                }

                let mut set_event =
                    SchedulerEvent::new(event_type::DIGITAL_SIGNAL_STATE_CHANGE, start);
                set_event.section_name = Some(self.resolve_section(&section.uid));
                set_event.signal = Some(signal_name.clone());
                set_event
                    .extra
                    .insert("bit".to_string(), serde_json::json!(bit_position));
                set_event
                    .extra
                    .insert("change".to_string(), serde_json::json!("SET"));

                let mut clear_event = SchedulerEvent::new(
                    event_type::DIGITAL_SIGNAL_STATE_CHANGE,
                    start + node.length,
                );
                clear_event.section_name = Some(self.resolve_section(&section.uid));
                clear_event.signal = Some(signal_name.clone());
                clear_event
                    .extra
                    .insert("bit".to_string(), serde_json::json!(bit_position));
                clear_event
                    .extra
                    .insert("change".to_string(), serde_json::json!("CLEAR"));

                trigger_set_events.push(set_event);
                trigger_clear_events.push(clear_event);
            }
        }

        let start_id = self.next_id();
        let section_name = self.resolve_section(&section.uid);

        let section_start = SchedulerEvent::new(event_type::SECTION_START, start)
            .with_id(start_id)
            .with_section_name(&section_name)
            .with_chain_element_id(start_id);

        let section_end = SchedulerEvent::new(event_type::SECTION_END, start + node.length)
            .with_id(self.next_id())
            .with_section_name(&section_name)
            .with_chain_element_id(start_id);

        let mut events = vec![section_start];
        events.extend(trigger_set_events);
        for child_list in children_events {
            events.extend(child_list);
        }
        events.extend(trigger_clear_events);
        events.push(section_end);

        events
    }

    fn visit_unrolled_loop(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
    ) -> Vec<EventList> {
        let mut children_event_lists = Vec::new();
        for child in &node.children {
            if *max_events == 0 {
                break;
            }
            let child_events = self.visit_node(&child.node, start + child.offset, max_events);
            children_event_lists.push(child_events);
        }
        children_event_lists
    }

    fn visit_compressed_loop(
        &mut self,
        node: &IrNode,
        loop_ir: &crate::ir::Loop,
        start: TinySamples,
        max_events: &mut usize,
    ) -> Vec<EventList> {
        let mut children_event_lists = Vec::new();

        if node.children.is_empty() {
            return children_event_lists;
        }

        let first_child = &node.children[0];
        let first_events =
            self.visit_node(&first_child.node, start + first_child.offset, max_events);

        let mut events_mut = first_events;
        if let Some(last_event) = events_mut
            .iter_mut()
            .rev()
            .find(|e| e.event_type == event_type::LOOP_ITERATION_END)
        {
            last_event
                .extra
                .insert("compressed".to_string(), serde_json::json!(true));
        }

        children_event_lists.push(events_mut);

        if self.expand_loops && node.children.len() == 1 {
            let prototype = &node.children[0].node;
            let prototype_length = prototype.length;
            let mut iteration_start = start + first_child.offset;

            for _ in 1..loop_ir.iterations.get() {
                if *max_events == 0 {
                    break;
                }

                iteration_start = iteration_start + prototype_length;
                let iteration_events = self.visit_node(prototype, iteration_start, max_events);

                if iteration_events.is_empty() {
                    break;
                }

                children_event_lists.push(iteration_events);
            }
        }

        children_event_lists
    }

    fn visit_loop(
        &mut self,
        node: &IrNode,
        loop_ir: &crate::ir::Loop,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let section_name = self.resolve_section(&loop_ir.uid);
        self.iteration_counter.insert(section_name.clone(), 0);

        if !Self::try_reserve_events(max_events, 3) {
            return Vec::new();
        }

        let mut children_event_lists = if loop_ir.compressed() {
            self.visit_compressed_loop(node, loop_ir, start, max_events)
        } else {
            self.visit_unrolled_loop(node, start, max_events)
        };

        for event_list in &mut children_event_lists {
            for event in event_list {
                if let Some(nesting) = event.extra.get_mut("nesting_level")
                    && let Some(level) = nesting.as_i64()
                {
                    *nesting = serde_json::json!(level + 1);
                }
            }
        }

        let start_id = self.next_id();
        let mut common_extras = HashMap::new();
        common_extras.insert("nesting_level".to_string(), serde_json::json!(0));

        let section_start = SchedulerEvent::new(event_type::SECTION_START, start)
            .with_id(start_id)
            .with_section_name(&section_name)
            .with_chain_element_id(start_id)
            .with_extras(common_extras.clone());

        let mut loop_end =
            SchedulerEvent::new(event_type::LOOP_END, start + node.length).with_id(self.next_id());
        loop_end.section_name = Some(section_name.clone());
        loop_end.extra.extend(common_extras.clone());

        let section_end = SchedulerEvent::new(event_type::SECTION_END, start + node.length)
            .with_id(self.next_id())
            .with_section_name(&section_name)
            .with_chain_element_id(start_id)
            .with_extras(common_extras);

        let mut events = vec![section_start];
        for child_list in children_event_lists {
            events.extend(child_list);
        }
        events.push(loop_end);
        events.push(section_end);

        events
    }

    fn visit_loop_iteration(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let section_name = match self.current_section_name() {
            Some(name) => name.to_string(),
            None => return Vec::new(),
        };

        let iteration = *self.iteration_counter.get(&section_name).unwrap_or(&0);

        let mut common_extras = HashMap::new();
        common_extras.insert("iteration".to_string(), serde_json::json!(iteration));
        common_extras.insert("nesting_level".to_string(), serde_json::json!(0));

        let needs_iteration_end = iteration == 0;
        let event_count = if needs_iteration_end { 3 } else { 2 };

        if !Self::try_reserve_events(max_events, event_count) {
            return Vec::new();
        }

        let budget_before_children = *max_events;
        let children_event_lists = self.generate_children_events(node, start, max_events, true);
        let children_events: EventList = children_event_lists.into_iter().flatten().collect();

        if children_events.is_empty() {
            *max_events = budget_before_children.saturating_add(event_count);
            return Vec::new();
        }

        self.iteration_counter
            .insert(section_name.clone(), iteration + 1);

        let mut events = Vec::new();

        let mut step_start =
            SchedulerEvent::new(event_type::LOOP_STEP_START, start).with_id(self.next_id());
        step_start.section_name = Some(section_name.clone());
        step_start.extra.extend(common_extras.clone());
        events.push(step_start);

        events.extend(children_events);

        let mut step_end = SchedulerEvent::new(event_type::LOOP_STEP_END, start + node.length)
            .with_id(self.next_id());
        step_end.section_name = Some(section_name.clone());
        step_end.extra.extend(common_extras.clone());
        events.push(step_end);

        if needs_iteration_end {
            let mut iteration_end =
                SchedulerEvent::new(event_type::LOOP_ITERATION_END, start + node.length)
                    .with_id(self.next_id());
            iteration_end.section_name = Some(section_name);
            iteration_end.extra.extend(common_extras);
            events.push(iteration_end);
        }

        events
    }

    fn visit_loop_iteration_preamble(
        &mut self,
        node: &IrNode,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        self.generic_visit(node, start, max_events)
    }

    fn visit_change_oscillator_phase(
        &mut self,
        node: &IrNode,
        change: &crate::ir::ChangeOscillatorPhase,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let signal_name = self.resolve_signal(&change.signal);

        let mut test_extras = HashMap::new();
        Self::add_optional_param(
            &mut test_extras,
            &change.increment,
            "increment_oscillator_phase",
        );
        Self::add_optional_param(&mut test_extras, &change.set, "set_oscillator_phase");

        if test_extras.is_empty() {
            return Vec::new();
        }

        let incr_phase_param_name = change
            .increment
            .as_ref()
            .and_then(|p| self.get_parameter_name(p));

        self.emit_bracketed_events_with_common(
            BracketedEventParams::new(
                event_type::DELAY_START,
                event_type::DELAY_END,
                &signal_name,
                start,
                start + node.length,
            ),
            max_events,
            |common| {
                common.insert("play_wave_id".to_string(), serde_json::json!("delay"));
                common.insert("parametrized_with".to_string(), serde_json::json!([]));
            },
            |start_only| {
                start_only.insert("play_wave_type".to_string(), serde_json::json!(2));
                start_only.insert("amplitude".to_string(), serde_json::json!(1.0));
                start_only.insert("phase".to_string(), serde_json::json!(0.0));

                Self::add_optional_param(
                    start_only,
                    &change.increment,
                    "increment_oscillator_phase",
                );
                if let Some(name) = incr_phase_param_name {
                    start_only.insert(
                        "phase_increment_parameter".to_string(),
                        serde_json::json!(name),
                    );
                }
                Self::add_optional_param(start_only, &change.set, "set_oscillator_phase");
            },
        )
    }

    fn visit_play_pulse(
        &mut self,
        node: &IrNode,
        play_pulse: &crate::ir::PlayPulse,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let signal_name = self.resolve_signal(&play_pulse.signal);
        let pulse_uid = self
            .id_store
            .resolve(play_pulse.pulse)
            .unwrap_or(UNKNOWN_LABEL)
            .to_string();

        let markers_json: Vec<MarkerJson> = play_pulse
            .markers
            .iter()
            .map(|m| MarkerJson {
                marker_selector: match m.marker_selector {
                    MarkerSelector::M1 => "marker1".to_string(),
                    MarkerSelector::M2 => "marker2".to_string(),
                },
                enable: m.enable,
                start: m.start.as_ref().map(|d| d.value()),
                length: m.length.as_ref().map(|d| d.value()),
                pulse_id: m
                    .pulse_id
                    .and_then(|id| self.id_store.resolve(id).map(|s| s.to_string())),
            })
            .collect();

        let amp_param_name = self.get_parameter_name(&play_pulse.amplitude);
        let incr_phase_param_name = play_pulse
            .increment_oscillator_phase
            .as_ref()
            .and_then(|p| self.get_parameter_name(p));

        let mut parametrized_with = Vec::new();
        if let Some(name) = &amp_param_name {
            parametrized_with.push(name.clone());
        }

        self.emit_bracketed_events_with_common(
            BracketedEventParams::new(
                event_type::PLAY_START,
                event_type::PLAY_END,
                &signal_name,
                start,
                start + node.length,
            ),
            max_events,
            |common| {
                common.insert("play_wave_id".to_string(), serde_json::json!(pulse_uid));
                common.insert(
                    "parametrized_with".to_string(),
                    serde_json::json!(parametrized_with),
                );
            },
            |start_only| {
                Self::add_amplitude(start_only, &play_pulse.amplitude);
                if let Some(name) = amp_param_name {
                    start_only.insert("amplitude_parameter".to_string(), serde_json::json!(name));
                }

                Self::add_optional_param(start_only, &play_pulse.phase, "phase");
                if !start_only.contains_key("phase") {
                    start_only.insert("phase".to_string(), serde_json::json!(0.0));
                }
                Self::add_optional_param(
                    start_only,
                    &play_pulse.increment_oscillator_phase,
                    "increment_oscillator_phase",
                );
                if let Some(name) = incr_phase_param_name {
                    start_only.insert(
                        "phase_increment_parameter".to_string(),
                        serde_json::json!(name),
                    );
                }
                Self::add_optional_param(
                    start_only,
                    &play_pulse.set_oscillator_phase,
                    "set_oscillator_phase",
                );

                if !markers_json.is_empty() {
                    start_only.insert("markers".to_string(), serde_json::json!(markers_json));
                }
            },
        )
    }

    fn visit_acquire(
        &mut self,
        _node: &IrNode,
        acquire: &crate::ir::Acquire,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let signal_name = self.resolve_signal(&acquire.signal);
        let handle = self
            .id_store
            .resolve(acquire.handle)
            .unwrap_or(UNKNOWN_LABEL)
            .to_string();

        let play_wave_id = if acquire.kernels.is_empty() {
            "".to_string()
        } else {
            acquire
                .kernels
                .iter()
                .filter_map(|k| self.id_store.resolve(*k))
                .collect::<Vec<_>>()
                .join(",")
        };

        // Multi-kernel acquires place acquire_handle on both START and END
        // (common) and omit amplitude/phase.  Single- or no-kernel acquires
        // put acquire_handle, amplitude and phase on START only.
        let multi_kernel = acquire.kernels.len() > 1;
        let handle_for_start = handle.clone();

        self.emit_bracketed_events_with_common(
            BracketedEventParams::new(
                event_type::ACQUIRE_START,
                event_type::ACQUIRE_END,
                &signal_name,
                start,
                start + acquire.integration_length,
            ),
            max_events,
            |common| {
                common.insert("play_wave_id".to_string(), serde_json::json!(play_wave_id));
                common.insert("parametrized_with".to_string(), serde_json::json!([]));
                if multi_kernel {
                    common.insert("acquire_handle".to_string(), serde_json::json!(handle));
                }
            },
            |start_only| {
                if !multi_kernel {
                    start_only.insert(
                        "acquire_handle".to_string(),
                        serde_json::json!(handle_for_start),
                    );
                    start_only.insert("amplitude".to_string(), serde_json::json!(1.0));
                    start_only.insert("phase".to_string(), serde_json::json!(0.0));
                }
            },
        )
    }

    fn visit_delay(
        &mut self,
        node: &IrNode,
        signal: &SignalUid,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let signal_name = self.resolve_signal(signal);
        self.emit_bracketed_events_with_common(
            BracketedEventParams::new(
                event_type::DELAY_START,
                event_type::DELAY_END,
                &signal_name,
                start,
                start + node.length,
            ),
            max_events,
            |common| {
                common.insert("play_wave_id".to_string(), serde_json::json!("delay"));
                common.insert("parametrized_with".to_string(), serde_json::json!([]));
            },
            |start_only| {
                start_only.insert("play_wave_type".to_string(), serde_json::json!(2));
                start_only.insert("amplitude".to_string(), serde_json::json!(1.0));
                start_only.insert("phase".to_string(), serde_json::json!(0.0));
            },
        )
    }

    fn extract_numeric_value<T>(param: &laboneq_dsl::types::ValueOrParameter<T>) -> Option<&T> {
        match param {
            laboneq_dsl::types::ValueOrParameter::Value(v) => Some(v),
            laboneq_dsl::types::ValueOrParameter::ResolvedParameter { value, .. } => Some(value),
            laboneq_dsl::types::ValueOrParameter::Parameter(_) => None,
        }
    }

    fn add_amplitude(
        extras: &mut HashMap<String, serde_json::Value>,
        amplitude: &laboneq_dsl::types::ValueOrParameter<laboneq_dsl::types::ComplexOrFloat>,
    ) {
        if let Some(amp) = Self::extract_numeric_value(amplitude) {
            match amp {
                laboneq_dsl::types::ComplexOrFloat::Complex(c) => {
                    extras.insert(
                        "amplitude".to_string(),
                        serde_json::json!({"real": c.re, "imag": c.im}),
                    );
                }
                laboneq_dsl::types::ComplexOrFloat::Float(f) => {
                    extras.insert("amplitude".to_string(), serde_json::json!(f));
                }
            }
        }
    }

    fn emit_bracketed_events_with_common<F, G>(
        &mut self,
        params: BracketedEventParams,
        max_events: &mut usize,
        build_common_extras: F,
        build_start_only_extras: G,
    ) -> EventList
    where
        F: FnOnce(&mut HashMap<String, serde_json::Value>),
        G: FnOnce(&mut HashMap<String, serde_json::Value>),
    {
        if !Self::try_reserve_events(max_events, 2) {
            return Vec::new();
        }

        let start_id = self.next_id();
        let section_name = self.current_section_name().map(|s| s.to_string());

        let mut common_extras = HashMap::new();
        build_common_extras(&mut common_extras);

        let mut start_extras = common_extras.clone();
        build_start_only_extras(&mut start_extras);

        let mut start_event = SchedulerEvent::new(params.start_type, params.start_time)
            .with_id(start_id)
            .with_signal(params.signal_name)
            .with_chain_element_id(start_id)
            .with_extras(start_extras);

        if let Some(ref sn) = section_name {
            start_event.section_name = Some(sn.clone());
        }

        let mut end_event = SchedulerEvent::new(params.end_type, params.end_time)
            .with_id(self.next_id())
            .with_signal(params.signal_name)
            .with_chain_element_id(start_id)
            .with_extras(common_extras);

        if let Some(ref sn) = section_name {
            end_event.section_name = Some(sn.clone());
        }

        vec![start_event, end_event]
    }

    fn add_optional_param(
        extras: &mut HashMap<String, serde_json::Value>,
        param: &Option<laboneq_dsl::types::ValueOrParameter<f64>>,
        name: &str,
    ) {
        if let Some(p) = param
            && let Some(value) = Self::extract_numeric_value(p)
        {
            extras.insert(name.to_string(), serde_json::json!(value));
        }
    }

    fn visit_match(
        &mut self,
        node: &IrNode,
        match_ir: &crate::ir::Match,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let section = crate::ir::Section {
            uid: match_ir.uid,
            triggers: Vec::new(),
            prng_setup: None,
        };

        let mut events = self.visit_section(node, &section, start, max_events);

        if let Some(section_start) = events.first_mut()
            && section_start.event_type == event_type::SECTION_START
        {
            match &match_ir.target {
                crate::ir::MatchTarget::Handle(handle) => {
                    let handle_name = self
                        .id_store
                        .resolve(*handle)
                        .unwrap_or(UNKNOWN_LABEL)
                        .to_string();
                    section_start
                        .extra
                        .insert("handle".to_string(), serde_json::json!(handle_name));
                    section_start
                        .extra
                        .insert("local".to_string(), serde_json::json!(match_ir.local));
                }
                crate::ir::MatchTarget::UserRegister(reg) => {
                    section_start
                        .extra
                        .insert("user_register".to_string(), serde_json::json!(reg));
                }
                crate::ir::MatchTarget::PrngSample(sample) => {
                    let sample_name = self
                        .id_store
                        .resolve(*sample)
                        .unwrap_or(UNKNOWN_LABEL)
                        .to_string();
                    section_start
                        .extra
                        .insert("prng_sample".to_string(), serde_json::json!(sample_name));
                }
                crate::ir::MatchTarget::SweepParameter(_) => {}
            }
        }

        events
    }

    fn visit_case(
        &mut self,
        node: &IrNode,
        case_ir: &crate::ir::Case,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        let section = crate::ir::Section {
            uid: case_ir.uid,
            triggers: Vec::new(),
            prng_setup: None,
        };

        let mut events = self.visit_section(node, &section, start, max_events);

        for event in &mut events {
            event
                .extra
                .insert("state".to_string(), serde_json::json!(case_ir.state));
        }

        events
    }

    fn visit_set_oscillator_frequency(
        &mut self,
        set_freq: &crate::ir::SetOscillatorFrequency,
        start: TinySamples,
        max_events: &mut usize,
    ) -> EventList {
        if !set_freq.oscillator_is_hardware {
            return Vec::new();
        }

        let mut events = Vec::new();

        // Sort signals by name for deterministic event ordering
        let mut values_sorted = set_freq.values.clone();
        values_sorted.sort_by_key(|(signal_uid, _)| {
            self.id_store
                .resolve(*signal_uid)
                .unwrap_or(UNKNOWN_LABEL)
                .to_string()
        });

        for (signal_uid, frequency) in &values_sorted {
            if *max_events == 0 {
                break;
            }

            let signal_name = self.resolve_signal(signal_uid);

            let freq_value = match frequency {
                laboneq_dsl::types::ValueOrParameter::Value(v) => *v,
                laboneq_dsl::types::ValueOrParameter::ResolvedParameter { value, .. } => *value,
                laboneq_dsl::types::ValueOrParameter::Parameter(_) => continue,
            };

            let start_id = self.next_id();
            let event = SchedulerEvent::new(event_type::SET_OSCILLATOR_FREQUENCY_START, start)
                .with_id(start_id)
                .with_signal(&signal_name)
                .with_chain_element_id(start_id)
                .with_extra("value".to_string(), serde_json::json!(freq_value));

            events.push(event);
            *max_events = max_events.saturating_sub(1);
        }

        events
    }
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/// Extract active bit positions from a bit mask.
fn extract_active_bits(mask: u8) -> Vec<u8> {
    (0..8).filter(|i| mask & (1 << i) != 0).collect()
}

/// Calculate preorder (depth/row) for each section based on time overlap.
fn calculate_preorder(
    node: &IrNode,
    current_depth: usize,
    section_info: &mut HashMap<String, SectionInfo>,
    id_store: &NamedIdStore,
) -> usize {
    if matches!(node.kind, IrKind::Root) {
        let mut max_depth = current_depth;
        for child in &node.children {
            let child_depth =
                calculate_preorder(&child.node, current_depth, section_info, id_store);
            max_depth = max_depth.max(child_depth);
        }
        return max_depth;
    }

    if let Some(info) = node.kind.section_info() {
        let section_name = id_store
            .resolve(*info.uid)
            .unwrap_or(UNKNOWN_LABEL)
            .to_string();
        section_info.insert(
            section_name.clone(),
            SectionInfo {
                section_display_name: section_name,
                preorder: current_depth,
            },
        );
    }

    if let IrKind::Loop(loop_obj) = &node.kind {
        let mut max_depth = current_depth;
        for child in &node.children {
            if matches!(child.node.kind, IrKind::LoopIteration) {
                let child_depth =
                    calculate_preorder(&child.node, current_depth, section_info, id_store);
                max_depth = max_depth.max(child_depth);
                // Loops without sweep parameters are cloned from a single
                // prototype and are structurally identical across iterations;
                // only the first one needs to be visited.  Loops *with* sweep
                // parameters differ per iteration (Match on the parameter is
                // dissolved into a different Case each time), so all iterations
                // must be visited.
                if loop_obj.parameters().is_empty() {
                    break;
                }
            }
        }
        return max_depth;
    }

    let mut children_with_times: Vec<_> = node
        .children
        .iter()
        .map(|child| {
            let start = child.offset;
            let end = start + child.node.length;
            (child, start, end)
        })
        .collect();
    children_with_times.sort_by_key(|(_, start, _)| *start);

    let mut section_range: Option<PreorderInterval> = None;
    let mut max_depth = current_depth;

    for (child, start, end) in children_with_times {
        if child.node.kind.section_info().is_none() {
            continue;
        }

        let child_interval = PreorderInterval { start, end };

        if let Some(range) = &section_range {
            if range.overlaps(&child_interval) {
                let child_depth =
                    calculate_preorder(&child.node, max_depth + 1, section_info, id_store);
                max_depth = max_depth.max(child_depth);
                section_range = Some(range.merge(&child_interval));
            } else {
                let child_depth =
                    calculate_preorder(&child.node, current_depth + 1, section_info, id_store);
                max_depth = max_depth.max(child_depth);
                section_range = Some(child_interval);
            }
        } else {
            let child_depth =
                calculate_preorder(&child.node, current_depth + 1, section_info, id_store);
            max_depth = max_depth.max(child_depth);
            section_range = Some(child_interval);
        }
    }

    max_depth
}

// =============================================================================
// SCHEDULE IMPLEMENTATION
// =============================================================================

impl Schedule {
    /// Generate a complete schedule from an IR tree.
    ///
    /// # Arguments
    /// * `root` - The root IR node to traverse
    /// * `expand_loops` - Whether to expand compressed loops
    /// * `max_events` - Maximum number of events to generate
    /// * `id_store` - ID store for resolving UIDs
    ///
    /// # Returns
    /// A Schedule containing event_list, section_info, and section_signals_with_children.
    /// Note: sampling_rates should be added separately by Python.
    ///
    /// # Performance Note
    /// This currently makes three separate tree traversals. Future optimization could
    /// consolidate these into a single pass by integrating section_info and section_signals
    /// collection into EventListGenerator. However, this would require significant refactoring
    /// due to the complex visitor pattern and different traversal requirements (preorder vs postorder).
    pub fn generate(
        root: &IrNode,
        expand_loops: bool,
        max_events: usize,
        id_store: &NamedIdStore,
    ) -> Self {
        let event_list = EventListGenerator::generate(root, expand_loops, max_events, id_store);

        let section_info = Self::generate_section_info(root, id_store);
        let section_signals = Self::generate_section_signals(root, id_store);

        Schedule {
            event_list,
            section_info,
            section_signals_with_children: section_signals,
        }
    }

    /// Generate section info with preorder map.
    ///
    /// The preorder map assigns a depth/row to each section based on time overlap.
    /// Sequential sections (not overlapping in time) get the same preorder (same row).
    /// Overlapping sections get different preorder values (different rows).
    /// This is used by PSV for visualization.
    fn generate_section_info(
        root: &IrNode,
        id_store: &NamedIdStore,
    ) -> HashMap<String, SectionInfo> {
        let mut section_info = HashMap::new();
        calculate_preorder(root, 0, &mut section_info, id_store);
        section_info
    }

    /// Generate section signals with children.
    ///
    /// For each section, collect all signals used within that section and its subsections.
    /// Parent sections include signals from all child sections (sorted alphabetically).
    /// Sections with no signals are excluded from the output.
    fn generate_section_signals(
        root: &IrNode,
        id_store: &NamedIdStore,
    ) -> HashMap<String, Vec<String>> {
        let mut section_signals: HashMap<String, Vec<String>> = HashMap::new();

        fn collect_signals(
            node: &IrNode,
            id_store: &NamedIdStore,
            section_signals: &mut HashMap<String, Vec<String>>,
        ) -> Vec<String> {
            let mut signals = Vec::new();

            let node_signals = node.kind.signals();
            for signal_uid in node_signals {
                let signal_name = id_store
                    .resolve(*signal_uid)
                    .unwrap_or(UNKNOWN_LABEL)
                    .to_string();
                if !signals.contains(&signal_name) {
                    signals.push(signal_name);
                }
            }

            for child in &node.children {
                let child_signals = collect_signals(&child.node, id_store, section_signals);
                for signal in child_signals {
                    if !signals.contains(&signal) {
                        signals.push(signal);
                    }
                }
            }

            if let Some(info) = node.kind.section_info() {
                let section_name = id_store
                    .resolve(*info.uid)
                    .unwrap_or(UNKNOWN_LABEL)
                    .to_string();
                section_signals.insert(section_name, signals.clone());
            }

            signals
        }

        collect_signals(root, id_store, &mut section_signals);

        section_signals
            .into_iter()
            .filter(|(_, signals)| !signals.is_empty())
            .map(|(section, mut signals)| {
                signals.sort();
                (section, signals)
            })
            .collect()
    }
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{PlayPulse, Section, Trigger};
    use crate::node::IrNode;
    use laboneq_common::named_id::NamedIdStore;
    use laboneq_dsl::types::*;
    use laboneq_units::tinysample::{TINYSAMPLE_DURATION, tiny_samples};
    use std::sync::Arc;

    // =============================================================================
    // TEST FIXTURES
    // =============================================================================

    fn setup_test_store() -> Arc<NamedIdStore> {
        let mut store = NamedIdStore::default();
        store.get_or_insert("sig1");
        store.get_or_insert("sig2");
        store.get_or_insert("section1");
        store.get_or_insert("section2");
        store.get_or_insert("pulse1");
        store.get_or_insert("handle1");
        Arc::new(store)
    }

    fn setup_generator(id_store: &NamedIdStore, expand_loops: bool) -> EventListGenerator<'_> {
        EventListGenerator::new(expand_loops, id_store)
    }

    fn create_test_id_store() -> Arc<NamedIdStore> {
        let mut store = NamedIdStore::default();
        store.get_or_insert("sig1");
        store.get_or_insert("sig2");
        store.get_or_insert("child_sig");
        store.get_or_insert("root");
        store.get_or_insert("child1");
        store.get_or_insert("child2");
        store.get_or_insert("empty_section");
        store.get_or_insert("pulse1");
        Arc::new(store)
    }

    // Helper functions to create UIDs from the test store
    fn section_uid(num: u32) -> SectionUid {
        let store = create_test_id_store();
        let name = match num {
            1 => "root",
            2 => "child1",
            3 => "child2",
            4 => "empty_section",
            _ => panic!("Unknown section number: {}", num),
        };
        SectionUid(store.get(name).unwrap())
    }

    fn signal_uid(num: u32) -> SignalUid {
        let store = create_test_id_store();
        let name = match num {
            1 => "sig1",
            2 => "sig2",
            3 => "child_sig",
            _ => panic!("Unknown signal number: {}", num),
        };
        SignalUid(store.get(name).unwrap())
    }

    fn pulse_uid(_num: u32) -> PulseUid {
        let store = create_test_id_store();
        PulseUid(store.get("pulse1").unwrap())
    }

    // =============================================================================
    // EVENT LIST GENERATOR TESTS
    // =============================================================================

    #[test]
    fn test_id_generation_starts_at_zero() {
        let store = setup_test_store();
        let mut generator = setup_generator(&store, false);
        assert_eq!(generator.next_id(), 0);
    }

    #[test]
    fn test_id_generation_sequential() {
        let store = setup_test_store();
        let mut generator = setup_generator(&store, false);
        assert_eq!(generator.next_id(), 0);
        assert_eq!(generator.next_id(), 1);
        assert_eq!(generator.next_id(), 2);
    }

    #[test]
    fn test_id_generation_unique_across_events() {
        let store = setup_test_store();
        let mut generator = setup_generator(&store, false);
        let section = Section {
            uid: SectionUid(store.get("section1").unwrap()),
            triggers: Vec::new(),
            prng_setup: None,
        };
        let node = IrNode::new(IrKind::Section(section), tiny_samples(1000));

        let events = generator.visit_node(&node, tiny_samples(0), &mut 100);

        let ids: Vec<usize> = events.iter().filter_map(|e| e.id).collect();
        let unique_ids: std::collections::HashSet<_> = ids.iter().collect();
        assert_eq!(ids.len(), unique_ids.len());
    }

    #[test]
    fn test_time_conversion_zero() {
        let time_ts = tiny_samples(0);
        let time_f64 = time_ts.value() as f64 * TINYSAMPLE_DURATION;
        assert_eq!(time_f64, 0.0);
    }

    #[test]
    fn test_time_conversion_positive() {
        let time_ts = tiny_samples(1000);
        let time_f64 = time_ts.value() as f64 * TINYSAMPLE_DURATION;
        assert!(time_f64 > 0.0);
        assert!(time_f64 < 1.0);
    }

    #[test]
    fn test_time_conversion_large_value() {
        let time_ts = tiny_samples(3_600_000_000_000i64);
        let time_f64 = time_ts.value() as f64 * TINYSAMPLE_DURATION;
        assert!((time_f64 - 1.0).abs() < 1e-10);
    }

    #[test]
    fn test_resolve_signal() {
        let store = setup_test_store();
        let generator = setup_generator(&store, false);
        let sig1_uid = SignalUid(store.get("sig1").unwrap());
        assert_eq!(generator.resolve_signal(&sig1_uid), "sig1");

        let sig2_uid = SignalUid(store.get("sig2").unwrap());
        assert_eq!(generator.resolve_signal(&sig2_uid), "sig2");
    }

    #[test]
    fn test_oscillator_is_hardware() {
        let store = setup_test_store();
        let sig1_uid = SignalUid(store.get("sig1").unwrap());

        // Hardware node: should produce a SET_OSCILLATOR_FREQUENCY_START event.
        let hw_node = IrNode::new(
            IrKind::SetOscillatorFrequency(crate::ir::SetOscillatorFrequency {
                values: vec![(sig1_uid, ValueOrParameter::Value(100e6))],
                oscillator_is_hardware: true,
            }),
            tiny_samples(0),
        );

        // Software node: should produce no events.
        let sw_node = IrNode::new(
            IrKind::SetOscillatorFrequency(crate::ir::SetOscillatorFrequency {
                values: vec![(sig1_uid, ValueOrParameter::Value(200e6))],
                oscillator_is_hardware: false,
            }),
            tiny_samples(0),
        );

        let mut root = IrNode::new(IrKind::Root, tiny_samples(0));
        root.add_child(tiny_samples(0), hw_node);
        root.add_child(tiny_samples(0), sw_node);

        let schedule = Schedule::generate(&root, false, 1000, &store);

        let osc_events: Vec<_> = schedule
            .event_list
            .iter()
            .filter(|e| e.event_type == event_type::SET_OSCILLATOR_FREQUENCY_START)
            .collect();

        // Only the hardware node should have produced an event.
        assert_eq!(osc_events.len(), 1);
        assert_eq!(
            osc_events[0].extra.get("value").and_then(|v| v.as_f64()),
            Some(100e6)
        );
    }

    #[test]
    fn test_section_stack() {
        let store = setup_test_store();
        let mut generator = setup_generator(&store, false);
        assert!(generator.current_section_name().is_none());

        generator.section_stack.push("section1".to_string());
        assert_eq!(generator.current_section_name(), Some("section1"));

        generator.section_stack.push("section2".to_string());
        assert_eq!(generator.current_section_name(), Some("section2"));

        generator.section_stack.pop();
        assert_eq!(generator.current_section_name(), Some("section1"));

        generator.section_stack.pop();
        assert!(generator.current_section_name().is_none());
    }

    fn build_comprehensive_ir_tree(id_store: &NamedIdStore) -> IrNode {
        use std::collections::HashMap;

        let sig_uid = SignalUid(id_store.get("sig1").unwrap());
        let sec_uid = SectionUid(id_store.get("section1").unwrap());

        let section = Section {
            uid: sec_uid,
            triggers: vec![Trigger {
                signal: sig_uid,
                state: 1,
            }],
            prng_setup: None,
        };

        let mut root = IrNode::new(IrKind::Section(section), tiny_samples(10000));

        let play_pulse = PlayPulse {
            signal: sig_uid,
            pulse: PulseUid(id_store.get("pulse1").unwrap()),
            amplitude: ValueOrParameter::Value(ComplexOrFloat::Float(0.8)),
            phase: Some(ValueOrParameter::Value(0.5)),
            increment_oscillator_phase: None,
            set_oscillator_phase: None,
            parameters: HashMap::new(),
            pulse_parameters: HashMap::new(),
            markers: vec![],
        };
        root.add_child(
            tiny_samples(0),
            IrNode::new(IrKind::PlayPulse(play_pulse), tiny_samples(1000)),
        );

        let acquire = crate::ir::Acquire {
            signal: sig_uid,
            handle: HandleUid(id_store.get("handle1").unwrap()),
            integration_length: tiny_samples(500),
            kernels: vec![],
            parameters: vec![],
            pulse_parameters: vec![],
        };
        root.add_child(
            tiny_samples(1000),
            IrNode::new(IrKind::Acquire(acquire), tiny_samples(500)),
        );

        let set_freq = crate::ir::SetOscillatorFrequency {
            values: vec![(sig_uid, ValueOrParameter::Value(100e6))],
            oscillator_is_hardware: true,
        };
        root.add_child(
            tiny_samples(1500),
            IrNode::new(IrKind::SetOscillatorFrequency(set_freq), tiny_samples(0)),
        );

        let phase_incr = crate::ir::ChangeOscillatorPhase {
            signal: sig_uid,
            increment: Some(ValueOrParameter::Value(0.25)),
            set: None,
        };
        root.add_child(
            tiny_samples(1500),
            IrNode::new(IrKind::ChangeOscillatorPhase(phase_incr), tiny_samples(0)),
        );

        let phase_set = crate::ir::ChangeOscillatorPhase {
            signal: sig_uid,
            increment: None,
            set: Some(ValueOrParameter::Value(0.0)),
        };
        root.add_child(
            tiny_samples(1500),
            IrNode::new(IrKind::ChangeOscillatorPhase(phase_set), tiny_samples(0)),
        );

        root
    }

    #[test]
    fn test_trigger_bit_extraction() {
        // Extract bits from mask 0b1010 (bits 1 and 3)
        let bits = extract_active_bits(0b1010);
        assert_eq!(bits, vec![1, 3]);

        // Extract bits from mask 0b0101 (bits 0 and 2)
        let bits = extract_active_bits(0b0101);
        assert_eq!(bits, vec![0, 2]);

        // No bits
        let bits = extract_active_bits(0b0000);
        assert_eq!(bits, Vec::<u8>::new());

        // All bits
        let bits = extract_active_bits(0b11111111);
        assert_eq!(bits, vec![0, 1, 2, 3, 4, 5, 6, 7]);
    }

    #[test]
    fn test_event_list_generation_comprehensive() {
        let store = setup_test_store();
        let mut generator = setup_generator(&store, false);

        let root = build_comprehensive_ir_tree(&store);
        let events = generator.visit_node(&root, tiny_samples(0), &mut 10000);

        assert!(!events.is_empty());

        let event_types: std::collections::HashSet<_> =
            events.iter().map(|e| &e.event_type).collect();
        assert!(event_types.contains(&event_type::SECTION_START));
        assert!(event_types.contains(&event_type::SECTION_END));
        assert!(event_types.contains(&event_type::PLAY_START));
        assert!(event_types.contains(&event_type::PLAY_END));
        assert!(event_types.contains(&event_type::ACQUIRE_START));
        assert!(event_types.contains(&event_type::ACQUIRE_END));

        let all_ids: std::collections::HashSet<_> = events.iter().filter_map(|e| e.id).collect();
        for event in &events {
            if let Some(chain_id) = event.chain_element_id {
                assert!(all_ids.contains(&chain_id));
            }
        }

        for i in 0..events.len() - 1 {
            assert!(events[i].time <= events[i + 1].time);
        }

        let ids: Vec<_> = events.iter().filter_map(|e| e.id).collect();
        let unique_ids: std::collections::HashSet<_> = ids.iter().collect();
        assert_eq!(ids.len(), unique_ids.len());
    }

    // =============================================================================
    // SCHEDULE TESTS
    // =============================================================================

    #[test]
    fn test_generate_section_info_preorder() {
        // Create section tree: root -> [child1, child2]
        let root_section = Section {
            uid: section_uid(1),
            triggers: Vec::new(),
            prng_setup: None,
        };
        let child1_section = Section {
            uid: section_uid(2),
            triggers: Vec::new(),
            prng_setup: None,
        };
        let child2_section = Section {
            uid: section_uid(3),
            triggers: Vec::new(),
            prng_setup: None,
        };

        let mut root = IrNode::new(IrKind::Section(root_section), tiny_samples(2000));
        root.add_child(
            tiny_samples(0),
            IrNode::new(IrKind::Section(child1_section), tiny_samples(1000)),
        );
        root.add_child(
            tiny_samples(1000),
            IrNode::new(IrKind::Section(child2_section), tiny_samples(1000)),
        );

        let id_store = create_test_id_store();
        let section_info = Schedule::generate_section_info(&root, &id_store);

        // Verify preorder numbering
        // Sequential sections (not overlapping) get the same depth
        assert_eq!(section_info.get("root").unwrap().preorder, 0);
        assert_eq!(section_info.get("child1").unwrap().preorder, 1);
        assert_eq!(section_info.get("child2").unwrap().preorder, 1);
    }

    #[test]
    fn test_generate_section_signals_hierarchy() {
        // Create sections with signal assignments
        let play1 = PlayPulse {
            signal: signal_uid(1),
            pulse: pulse_uid(1),
            amplitude: ValueOrParameter::Value(ComplexOrFloat::Float(1.0)),
            phase: None,
            increment_oscillator_phase: None,
            set_oscillator_phase: None,
            parameters: HashMap::new(),
            pulse_parameters: HashMap::new(),
            markers: Vec::new(),
        };

        let play_child = PlayPulse {
            signal: signal_uid(3),
            pulse: pulse_uid(1),
            amplitude: ValueOrParameter::Value(ComplexOrFloat::Float(1.0)),
            phase: None,
            increment_oscillator_phase: None,
            set_oscillator_phase: None,
            parameters: HashMap::new(),
            pulse_parameters: HashMap::new(),
            markers: Vec::new(),
        };

        let child_section = Section {
            uid: section_uid(2),
            triggers: Vec::new(),
            prng_setup: None,
        };
        let mut child = IrNode::new(IrKind::Section(child_section), tiny_samples(1000));
        child.add_child(
            tiny_samples(0),
            IrNode::new(IrKind::PlayPulse(play_child), tiny_samples(500)),
        );

        let parent_section = Section {
            uid: section_uid(1),
            triggers: Vec::new(),
            prng_setup: None,
        };
        let mut parent = IrNode::new(IrKind::Section(parent_section), tiny_samples(2000));
        parent.add_child(
            tiny_samples(0),
            IrNode::new(IrKind::PlayPulse(play1), tiny_samples(500)),
        );
        parent.add_child(tiny_samples(1000), child);

        let id_store = create_test_id_store();
        let section_signals = Schedule::generate_section_signals(&parent, &id_store);

        // Parent should include child signals
        let parent_signals = section_signals.get("root").unwrap();
        assert!(parent_signals.contains(&"sig1".to_string()));
        assert!(parent_signals.contains(&"child_sig".to_string()));

        // Child should only have its own signal
        let child_signals = section_signals.get("child1").unwrap();
        assert!(child_signals.contains(&"child_sig".to_string()));
        assert!(!child_signals.contains(&"sig1".to_string()));
    }
}
