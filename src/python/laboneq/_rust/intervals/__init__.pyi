from collections.abc import Iterable
from typing import TypeVar, Generic, Callable

IntervalData = TypeVar("IntervalData")

class Interval(Generic[IntervalData]):
    def __init__(
        self, begin: int, end: int, data: IntervalData | None = None
    ) -> None: ...
    @property
    def begin(self) -> int: ...
    @property
    def end(self) -> int: ...
    @property
    def data(self) -> IntervalData: ...
    def overlap(self, begin: int, end: int | None = None) -> bool: ...
    def length(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...

class IntervalTree(Generic[IntervalData]):
    def __init__(
        self, intervals: list[Interval[IntervalData]] | None = None
    ) -> None: ...
    def addi(self, begin: int, end: int, data: IntervalData | None = None) -> None: ...
    def merge_overlaps(self, func: Callable[[object, object], object]) -> None: ...
    def at(self, value: int) -> list[Interval[IntervalData]]: ...
    def overlap(self, begin: int, end: int) -> list[Interval[IntervalData]]: ...
    def overlaps_range(self, begin: int, end: int) -> bool: ...
    @property
    def intervals(self) -> list[Interval[IntervalData]]: ...
    def begin(self) -> int: ...
    def end(self) -> int: ...
    def is_empty(self) -> bool: ...
    def length(self) -> int: ...
    def sort(self) -> None: ...
    def is_sorted(self) -> bool: ...

class MinimumWaveformLengthViolation(Exception): ...

def calculate_intervals(*args, **kwargs) -> Iterable[Interval[IntervalData]]: ...
